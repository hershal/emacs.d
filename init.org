* init.org
** introduction
** use-package
First we must initialize use-package.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

  (package-initialize)

  ;; Bootstrap `use-package'
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)
#+END_SRC
** after
#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro after (mode &rest body)
    "`eval-after-load' MODE evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,mode
       '(progn ,@body)))
#+END_SRC
** whoami
Who am I?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name "Hershal Bhave"
      user-mail-address "hershal.bhave@gmail.com")
#+END_SRC
** misc-defaults
Let's set some (sensible) defaults that don't go anywhere else.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore)
  (setq search-whitespace-regexp "[ \t\r\n\-]+")
#+END_SRC
** hb-mode
Set up hb-mode and hb-mode-map.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar hb-mode-map (make-keymap) "hb-mode keymap.")
  (define-minor-mode hb-mode
    "Toggle hb-mode.
       A minor mode so that my key settings override any major modes'."
    t " hb" 'hb-mode-map)
  (hb-mode 1)               ;enable my minor mode, except in minibuffer
  (diminish 'hb-mode)
  (add-hook 'minibuffer-setup-hook (lambda() (hb-mode 0)))
#+END_SRC
** test-map

* os-specific
** linux
** osx
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (equal window-system 'ns)
      (set-default-font "Menlo 10"))
#+END_SRC
* general
** window system
These usually exist when using a window system. Let's make that not
so.
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (window-system)
      (progn (scroll-bar-mode 0)
             (tool-bar-mode 0)
             (blink-cursor-mode 0)
             (set-fringe-mode 0)))
#+END_SRC

This exists regardless of whether we use a windowing system, so
disable those too.
#+BEGIN_SRC emacs-lisp :tangle yes
(menu-bar-mode 0)
#+END_SRC

** portables
Activate display-battery-mode.
#+BEGIN_SRC emacs-lisp :tangle yes
  (display-battery-mode 1)
#+END_SRC

** nuisances
Remove the yes-or-no prompts and replace them with y-or-n.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Also remove all dialog boxes
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice yes-or-no-p (around prevent-dialog activate)
    "Prevent yes-or-no-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
  (defadvice y-or-n-p (around prevent-dialog-yorn activate)
    "Prevent y-or-n-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
#+END_SRC

** general-bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (bind-key "C-c C-m"    'recompile hb-mode-map)
  (bind-key "C-c m"      'compile hb-mode-map)
  (bind-key "C-x C-b"    'ido-switch-buffer hb-mode-map)
  (bind-key "C-x O"      'ff-find-other-file hb-mode-map)
  (bind-key "C-'"        'execute-extended-command hb-mode-map)
  (bind-key "C-x C-h"    'hb-delete-trailing-whitespace-untabify hb-mode-map)
  (bind-key "M-|"        'transpose-frame hb-mode-map)
  (bind-key "C-M-S-q"    'fill-region-as-paragraph hb-mode-map)
  (bind-key "M-'"        'query-replace hb-mode-map)
  (bind-key "M-\""       'query-replace-regexp hb-mode-map)
  (bind-key "M-Q"        'auto-fill-mode hb-mode-map)
  (bind-key "C-o"        'split-line hb-mode-map)
  (bind-key "C-x K"      'kill-buffer-and-window hb-mode-map)
  (bind-key "C-x C-S-f"  'find-file-other-window hb-mode-map)
  (bind-key "C-'"        'execute-extended-command hb-mode-map)
  (bind-key "M-SPC"      'cycle-spacing hb-mode-map)
  (bind-key "C-M-'"      'replace-regexp hb-mode-map)
#+END_SRC
** general-general
Very general stuff here. I don't know where to categorize this, so
general-general.
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-auto-revert-mode t)
  (set-buffer-file-coding-system 'unix)
  (setq-default indent-tabs-mode nil)

  ;;; show paren mode
  (show-paren-mode t)
  (setq show-paren-style 'mixed)

  (setq vc-follow-symlinks t)
  (setq ediff-auto-refine 'on)
  (setq ring-bell-function 'ignore)
  (setq backup-directory-alist `((".*" . , "~/.emacs-backups/")))
  (setq tramp-auto-save-directory "~/.emacs-backups/")
  (setq kill-whole-line t)
  (setq size-indication-mode t)

  (setq display-time-24hr-format t)
  (setq display-time-mode t)
#+END_SRC

** hydras
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra ()
    (hb/configure-hydra-movement)
    (hb/configure-hydra-fold-this))
#+END_SRC
*** movement
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-movement ()
    (setq scroll-amount 10)
    (defhydra hb/hydra-movement (hb-mode-map "M-m" :color red)
      "movement"
      ("j"     (scroll-up scroll-amount)     "down")
      ("k"     (scroll-down scroll-amount)   "up")
      ("n"     hb/scroll-up-halfpage         "down half")
      ("p"     hb/scroll-down-halfpage       "up half")
      ("SPC"   scroll-up                     "down full")
      ("S-SPC" scroll-down                   "up full")
      ("s"     isearch-forward               "isearch")
      ("v"     visual-line-mode              "visual-line")
      ("a"     auto-fill-mode                "auto-fill-mode")
      ("f"     follow-mode                   "follow-mode")
      ("w"     ace-window                    "ace-window")
      ("8"     follow-mode-80-char-compliant "follow-mode-80-char")))
#+END_SRC
*** fold-this
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-fold-this ()
    (defhydra hb/fold-this (hb-mode-map "C-x f" :color blue)
      "fold-this"
      ("f" fold-this "fold-this")
      ("u" fold-this-unfold-at-point "unfold-at-point")
      ("a" fold-this-unfold-all "unfold-all")))
#+END_SRC
* packages
** ace-window
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-window
    :init (progn
            (bind-key "M-p" 'ace-window hb-mode-map)
            (setq aw-leading-char-style 'path
                  aw-keys (number-sequence 97 (+ 97 26)))
            (custom-set-faces '(aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0)))))))
#+END_SRC
** auto-complete
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auto-complete
    :init (setq ac-use-menu-map t)
    :config (progn
              (ac-config-default)
              (setq-default ac-auto-show-menu 0.1)
              (setq-default ac-sources (append '(ac-source-imenu) ac-sources))
              (define-key ac-menu-map (kbd "C-n") nil)
              (define-key ac-menu-map (kbd "C-p") nil)
              (global-auto-complete-mode))
    :diminish "")
#+END_SRC
** bind-key
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bind-key)
#+END_SRC
** bliss-theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bliss-theme
    :config (progn (load-theme 'bliss t)
                   (set-face-attribute 'highlight nil :foreground 'nil :underline 'nil :background "#222222")))
#+END_SRC
** bury-successful-compilation
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bury-successful-compilation
    :config (bury-successful-compilation))
#+END_SRC
** TODO desktop-mode
** diminish
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package diminish
    :commands diminish)
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :config (progn
              (bind-key "C-=" 'er/expand-region hb-mode-map)
              (bind-key "C-+" 'er/contract-region) hb-mode-map))
#+END_SRC
** fold-this
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fold-this)
#+END_SRC
** icomplete+
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package icomplete+
    :config (icomplete-mode))
#+END_SRC
** ido-hacks
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido-hacks
    :init (progn
            (ido-mode t)
            (setq ido-enable-flex-matching t
                  ido-everywhere t
                  ido-max-directory-size 100000
                  ido-create-new-buffer 'always
                  ido-default-file-method 'selected-window
                  ido-default-buffer-method 'selected-window)))
#+END_SRC
** multiple-cursors
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc ()
    (hb/configure-mc-isearch)
    (hb/configure-mc-bindings)
    (hb/configure-mc-fixes))
#+END_SRC
*** mc-isearch
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-isearch ()
        (defvar jc/mc-search--last-term nil)
        (defun jc/mc-search (search-command)
          ;; Read new search term when not repeated command or applying to fake cursors
          (when (and (not mc--executing-command-for-fake-cursor)
                     (not (eq last-command 'jc/mc-search-forward))
                     (not (eq last-command 'jc/mc-search-backward)))
            (setq jc/mc-search--last-term (read-from-minibuffer "Search: ")))
          (funcall search-command jc/mc-search--last-term))
        (defun jc/mc-search-forward ()
          "Simplified version of forward search that supports multiple cursors"
          (interactive)
          (jc/mc-search 'search-forward))
        (defun jc/mc-search-backward ()
          "Simplified version of backward search that supports multiple cursors"
          (interactive)
          (jc/mc-search 'search-backward)))
  (bind-key "C-s" 'jc/mc-search-forward mc/keymap)
  (bind-key "C-s" 'jc/mc-search-backward mc/keymap)
#+END_SRC
*** bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-bindings ()
    (bind-key "C-S-c C-S-c" 'mc/edit-lines hb-mode-map)
    (bind-key "C-S-SPC" 'set-rectangular-region-anchor hb-mode-map)
    (bind-key "C->" 'mc/mark-next-like-this hb-mode-map)
    (bind-key "C-<" 'mc/mark-previous-like-this hb-mode-map)
    (bind-key "C-c C-<" 'mc/mark-all-like-this hb-mode-map)
    (bind-key "C-c C->" 'mc/mark-all-like-this-dwim hb-mode-map)
    (bind-key "C-c ~" 'mc/insert-numbers hb-mode-map)
    (bind-key "M-~" 'mc/sort-regions hb-mode-map)
    (bind-key "C-~" 'mc/reverse-regions hb-mode-map)
    (bind-key "C-S-c C-e" 'mc/edit-ends-of-lines hb-mode-map)
    (bind-key "C-S-c C-a" 'mc/edit-beginnings-of-lines hb-mode-map))
#+END_SRC
*** fixes
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-fixes ()
    (bind-key "C-SPC" 'just-one-space mc/keymap))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :idle-priority 5
    :config (progn
            (hb/configure-mc)))
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :init (progn (setq org-src-window-setup 'other-window
                       org-startup-indented t)
                 (after 'org-indent
                   (diminish 'org-indent-mode ""))))
#+END_SRC
** paredit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paredit
      :config (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
      :diminish "")
#+END_SRC
** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :config (global-undo-tree-mode)
    :diminish "")
#+END_SRC
** TODO uniquify
** hydra
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :config (hb/configure-hydra))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :idle-priority 5
    :commands magit-status
    :init (progn (bind-key "C-c g" 'magit-status hb-mode-map)
                 (setq magit-auto-revert-mode-lighter "")))
#+END_SRC
** monochrome-theme
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package monochrome-theme
    :idle-priority 5)
#+END_SRC
** transpose-frame
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package transpose-frame
    :config (bind-key "M-|" 'transpose-frame hb-mode-map))
#+END_SRC
** winner-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winner
    :defer t
    :idle (winner-mode 1))
#+END_SRC
** windmove
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package windmove
    :config (windmove-default-keybindings))
#+END_SRC
** writegood-mode
#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode
    :idle-priority 5)
#+END_SRC
** paredit-everywhere
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paredit-everywhere
      :config (add-hook 'prog-mode-hook 'paredit-everywhere-mode)
      :diminish "")
#+END_SRC
* major-modes
** c++
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-c++ ()
      (setq c-basic-offset 4
            comment-start "/* "
            comment-end " */"))
  (add-hook 'c++-mode-hook 'hb/configure-c++)
#+END_SRC
* macros
** follow-mode-80-char-compliant
Thanks to @EricCrosson.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun follow-mode-80-char-compliant()
    "Open the current buffer in `follow-mode' in as many 80-char
  windows as you can fit on this screen."
    (interactive)
    (delete-other-windows)
    (follow-mode 1)
    (let ((width (window-total-width nil 'floor)))
      (while (> width 80)
        (split-window-horizontally)
        (balance-windows)
        (setq width (window-total-width nil 'floor))))
    (delete-window)
    (balance-windows)
    (recenter-top-bottom))
#+END_SRC
** delete-trailing-whitespace-untabify
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/delete-trailing-whitespace-untabify ()
    (interactive)
    (delete-trailing-whitespace (point-min) (point-max))
    (untabify (point-min) (point-max)))
  (add-hook 'before-save-hook 'hb/delete-trailing-whitespace-untabify)
#+END_SRC
** scroll-halfpage
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun window-half-height ()
    (max 1 (/ (1- (window-height (selected-window))) 2)))

  (defun hb/scroll-up-halfpage ()
    (interactive)
    (scroll-up (window-half-height)))

  (defun hb/scroll-down-halfpage ()
    (interactive)
    (scroll-down (window-half-height)))
#+END_SRC
** back-to-indentation-or-beginning
This frees up M-m by making C-a do double-duty as beginning-of-line
and back-to-indentation
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun back-to-indentation-or-beginning ()
    (interactive)
    (if (bolp) (back-to-indentation) (beginning-of-line)))
  (bind-key "C-a" 'back-to-indentation-or-beginning hb-mode-map)
#+END_SRC
** visit-term-buffer
Quickly visit an open term buffer
Credits: @bbatsov, http://emacsredux.com/blog/2013/03/29/terminal-at-your-fingertips/
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun visit-term-buffer ()
    "Create or visit a terminal buffer."
    (interactive)
    (if (not (get-buffer "*ansi-term*"))
        (progn
          (split-window-sensibly (selected-window))
          (other-window 1)
          (ansi-term (getenv "SHELL")))
      (switch-to-buffer-other-window "*ansi-term*")))
  (bind-key "C-c t" 'visit-term-buffer hb-mode-map)
#+END_SRC
** ido-goto-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ido-goto-symbol (&optional symbol-list)
    "Refresh imenu and jump to a place in the buffer using Ido."
    (interactive)
    (unless (featurep 'imenu)
      (require 'imenu nil t))
    (cond
     ((not symbol-list)
      (let ((ido-mode ido-mode)
            (ido-enable-flex-matching
             (if (boundp 'ido-enable-flex-matching)
                 ido-enable-flex-matching t))
            name-and-pos symbol-names position)
        (unless ido-mode
          (ido-mode 1)
          (setq ido-enable-flex-matching t))
        (while (progn
                 (imenu--cleanup)
                 (setq imenu--index-alist nil)
                 (ido-goto-symbol (imenu--make-index-alist))
                 (setq selected-symbol
                       (ido-completing-read "Symbol? " symbol-names))
                 (string= (car imenu--rescan-item) selected-symbol)))
        (unless (and (boundp 'mark-active) mark-active)
          (push-mark nil t nil))
        (setq position (cdr (assoc selected-symbol name-and-pos)))
        (cond
         ((overlayp position)
          (goto-char (overlay-start position)))
         (t
          (goto-char position)))))
     ((listp symbol-list)
      (dolist (symbol symbol-list)
        (let (name position)
          (cond
           ((and (listp symbol) (imenu--subalist-p symbol))
            (ido-goto-symbol symbol))
           ((listp symbol)
            (setq name (car symbol))
            (setq position (cdr symbol)))
           ((stringp symbol)
            (setq name symbol)
            (setq position
                  (get-text-property 1 'org-imenu-marker symbol))))
          (unless (or (null position) (null name)
                      (string= (car imenu--rescan-item) name))
            (add-to-list 'symbol-names name)
            (add-to-list 'name-and-pos (cons name position))))))))
  (bind-key "C-c i" 'ido-goto-symbol hb-mode-map)
  (bind-key "C-c I" 'imenu hb-mode-map)
#+END_SRC
** comment-eclipse
#+BEGIN_SRC emacs-lisp :tangle yes
    (defun comment-eclipse ()
          (interactive)
          (let ((start (line-beginning-position))
                (end (line-end-position)))
            (when (region-active-p)
              (setq start (save-excursion
                            (goto-char (region-beginning))
                            (beginning-of-line)
                            (point))
                    end (save-excursion
                          (goto-char (region-end))
                          (end-of-line)
                          (point))))
            (comment-or-uncomment-region start end)))
  (bind-key "C-;" 'comment-eclipse hb-mode-map)
#+END_SRC
* conclusion
#+BEGIN_SRC emacs-lisp

#+END_SRC

* TODO [0/19] todos
** TODO insert delimeters (), [], {}, etc
** TODO :emacs: macro to create 'BEGIN_SRC emacs-lisp :tangle yes' blocks
** TODO :autocomplete: test if auto-complete is working
** TODO :autocomplete:org: get ac-complete-org working
** TODO :org: find out how to use orgmode tags properly
Reference [[http://orgmode.org/manual/Tags.html][the org manual]].
** TODO :magit:hydra: investigate if magit needs hydras
** TODO :magit: find out why magit doesn't work
** TODO :annoy:makefile: add hook to makefile-mode to tabify
- alternatively do not remove the whitespace in this mode
- could just do a buffer-local remove-hook, if that is possible
** TODO :annoy:org: don't allow 'org-edit-special' to clobber my window config
** TODO :annoy: make something similar to esc's should-have functions
** TODO :annoy: delete-that-newly-opened-window
- add to movement hydra ("d"?)
** TODO :annoy: reopen-in-other-window
- add to movement hydra ("o"?)
** TODO custom mode
- turn on and off various minor modes
** TODO change all bindings to bind-key
** TODO get paredit-everywhere-mode working
** TODO evaluate ido-complete-space-or-hyphen
** TODO :annoy:org: add org fly-dictate minor mode
Should automatically correct dictation issues. Prospective features:
- make heading titles capitalized
  - except when there are more than two consecutive upper case characters
    - if so, ignore that word
    - else continue capitalizing
- automatically create definitions based on dictating a specific word
  or phrase:
  - maybe a way to dictate a M-x command?
    - "dictate-meta-x"!
- if there is a capital letter in the middle of a word, that probably
  means that the word needs to be split
  - e.g. thisThat -> this that
  - determine when the concatenation needs to be split into two
    sentences or two words
** TODO :magit:hydra:git: make git hydra
should have some common vc, magit, git-messenger, and git-timemachine
commands
** TODO :annoy: set up c++ indentation rules properly
- public/private spacing
- verify c-basic-offset
- set up style
- constructor arguments should be auto-filled and c-basic-offset
  tabbed
