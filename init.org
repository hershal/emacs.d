* init.org
** introduction
** use-package
First we must initialize use-package.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

  (package-initialize)

  ;; Bootstrap `use-package'
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)
#+END_SRC
** after
This is a cool macro from milkypostman which runs a function body
after a mode loads into emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro after (mode &rest body)
    "`eval-after-load' MODE evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,mode
       '(progn ,@body)))
#+END_SRC
** whoami
Who am I?

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Hershal Bhave"
        user-mail-address "hershal.bhave@gmail.com")
#+END_SRC
** misc-defaults
Let's set some (sensible) defaults that don't go anywhere else.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore
        search-whitespace-regexp "[ \t\r\n\-]+"
        inhibit-startup-screen t)
#+END_SRC
** hb-mode
Set up hb-mode and hb-mode-map.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar hb-mode-map (make-keymap) "hb-mode keymap.")
  (define-minor-mode hb-mode
    "Toggle hb-mode.
       A minor mode so that my key settings override any major modes'."
    t " hb" 'hb-mode-map)
  (hb-mode 1)               ;enable my minor mode, except in minibuffer
  (diminish 'hb-mode)
  (add-hook 'minibuffer-setup-hook (lambda() (hb-mode 0)))
#+END_SRC
** faces
These are some faces that I like to skip around in sometimes. I mainly
use either Menlo of courier these days, but maybe sometime I'd like to
try out others. This makes trying out fonts easy.

*** meslo-face
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun meslo-face (&optional size)
    (interactive "N")
    (if size
        (set-frame-font (concat "Meslo LG S " (number-to-string size)))
      (set-frame-font "Meslo LG S 7")))
#+END_SRC
*** menlo-face
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun menlo-face (&optional size)
    (interactive "N")
    (if size
        (set-frame-font (concat "Menlo " (number-to-string size)))
      (set-frame-font "Menlo 7")))
#+END_SRC
*** bitstream-face
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun bitstream-face (&optional size)
    (interactive "N")
    (if size
        (set-frame-font (concat "Bitstream Vera Sans Mono " (number-to-string size)))
      (set-frame-font "Bitstream Vera Sans Mono 8")))
#+END_SRC
*** courier-face
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun courier-face ()
    (interactive)
    (set-frame-font "-adobe-courier-medium-r-normal-*-*-*-100-100-*-60-iso10646-1"))
#+END_SRC
* os-specific
Depending on the OS emacs is currently running on, I might need to
make some changes.

** linux
On Linux, I may or may not have some fonts installed. I check if each
one exists on the system in order of preference and use the most
preferred font that exists on the current system. I also bind some
keys and remove the menu-bar.

#+BEGIN_SRC emacs-lisp :tangle yes
  (if (equal window-system 'x)
      (progn
        (cond
         ((find-font (font-spec :name "Menlo"))
          (menlo-face))
         ((find-font (font-spec :name "Meslo LG S"))
          (meslo-face))
         ((find-font (font-spec :name "Bitstream Vera Sans Mono"))
          (bitstream-face))
         ((find-font (font-spec :name "-adobe-courier-medium-r-normal-*-*-*-100-100-*-60-iso10646-1"))
          (courier-face)))
        (bind-key "s-u" 'revert-buffer hb-mode-map)
        (bind-key "s-L" 'goto-line hb-mode-map)
    (menu-bar-mode 0)))
#+END_SRC
** osx
On OSX, I decrease the font size and turn on the menu-bar since it
doesn't impact screen real-estate. If ports is in use, I try to use
that version of bash.

#+BEGIN_SRC emacs-lisp :tangle yes
  (if (equal window-system 'ns)
      (progn
        (set-frame-font "Menlo 10")
        (menu-bar-mode 1)
        (if (file-exists-p "/opt/local/bin/bash")
            (setq shell-file-name "/opt/local/bin/bash"))))
#+END_SRC
* general
** window-system
These usually exist when using a window system. Let's make that not
so.
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (window-system)
      (progn (scroll-bar-mode 0)
             (tool-bar-mode 0)
             (blink-cursor-mode 0)
             (set-fringe-mode 0)))
#+END_SRC
** portables
Activate display-battery-mode. Not sure what happens when I'm on a
desktop.

#+BEGIN_SRC emacs-lisp :tangle yes
  (display-battery-mode 1)
#+END_SRC
** nuisances
These are things that annoy me with emacs. Let's make those annoyances
go away.

Remove the yes-or-no prompts and replace them with y-or-n.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Also remove all dialog boxes.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice yes-or-no-p (around prevent-dialog activate)
    "Prevent yes-or-no-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
  (defadvice y-or-n-p (around prevent-dialog-yorn activate)
    "Prevent y-or-n-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
#+END_SRC

Enable the recursive minibuffer. Remember though, with great power
comes great responsiblity. From the [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Recursive-Edit.html][Emacs Manual]]:

#+BEGIN_QUOTE
In general, we try to minimize the use of recursive editing levels in
GNU Emacs. This is because they constrain you to “go back” in a
particular order --— from the innermost level toward the top
level. When possible, we present different activities in separate
buffers so that you can switch between them as you please. Some
commands switch to a new major mode which provides a command to switch
back. These approaches give you more flexibility to go back to
unfinished tasks in the order you choose.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq enable-recursive-minibuffers t)
#+END_SRC

Remove the "buffer X has a running process" query for
process buffers.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq kill-buffer-query-functions
        (remove 'process-kill-buffer-query-function
                kill-buffer-query-functions))
#+END_SRC

Black magic doesn't exist.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq disabled-command-function nil)
#+END_SRC
** bindings
Some general-purpose keybindings.

#+BEGIN_SRC emacs-lisp :tangle yes
  (bind-key "C-c C-m"    'recompile hb-mode-map)
  (bind-key "C-c m"      'compile hb-mode-map)
  (bind-key "C-x C-b"    'ido-switch-buffer hb-mode-map)
  (bind-key "C-x O"      'ff-find-other-file hb-mode-map)
  (bind-key "C-'"        'execute-extended-command hb-mode-map)
  (bind-key "C-x C-h"    'hb/delete-trailing-whitespace-untabify hb-mode-map)
  (bind-key "M-|"        'transpose-frame hb-mode-map)
  (bind-key "C-M-S-q"    'fill-region-as-paragraph hb-mode-map)
  (bind-key "M-'"        'query-replace hb-mode-map)
  (bind-key "M-\""       'query-replace-regexp hb-mode-map)
  (bind-key "M-Q"        'fill-region hb-mode-map)
  (bind-key "C-o"        'split-line hb-mode-map)
  (bind-key "C-x K"      'kill-buffer-and-window hb-mode-map)
  (bind-key "C-x C-S-f"  'find-file-other-window hb-mode-map)
  (bind-key "C-'"        'execute-extended-command hb-mode-map)
  (bind-key "M-SPC"      'cycle-spacing hb-mode-map)
  (bind-key "M-;"        'replace-regexp hb-mode-map)
#+END_SRC
** general-general
General stuff here. I don't know where to categorize this, so
general-general.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-auto-revert-mode t)
  (set-buffer-file-coding-system 'unix)
  (setq-default indent-tabs-mode nil)

  (setq vc-follow-symlinks t
        ediff-auto-refine 'on
        ring-bell-function 'ignore
        backup-directory-alist `((".*" . , "~/.emacs-backups/"))
        tramp-auto-save-directory "~/.emacs-backups/"
        kill-whole-line t
        size-indication-mode t
        display-time-24hr-format t
        display-time-mode t
        revert-without-query '(".*"))

  (toggle-truncate-lines 1)
  (column-number-mode 1)
#+END_SRC

** hydras
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra ()
    (hb/configure-hydra-movement)
    (hb/configure-hydra-fold-this)
    (hb/configure-hydra-options))
#+END_SRC
*** movement
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-movement ()
    (setq scroll-amount 10)
    (defhydra hb/hydra-movement (hb-mode-map "M-m" :color red)
      "movement"
      ("j"     (scroll-up scroll-amount)     "down")
      ("k"     (scroll-down scroll-amount)   "up")
      ("f"     hb/scroll-up-halfpage         "down half")
      ("b"     hb/scroll-down-halfpage       "up half")
      ("SPC"   scroll-up                     "down full")
      ("S-SPC" scroll-down                   "up full")
      ("s"     isearch-forward               "isearch")
      ("v"     visual-line-mode              "visual-line")
      ("a"     auto-fill-mode                "auto-fill-mode")
      ("i"     set-fill-column               "fill-column")
      ("o"     follow-mode-80-char           "follow-mode-80-char")
      ("w"     ace-window                    "ace-window")))
#+END_SRC
*** fold-this
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-fold-this ()
    (defhydra hb/fold-this (hb-mode-map "C-x f" :color blue)
      "fold-this"
      ("f" fold-this "fold-this")
      ("u" fold-this-unfold-at-point "unfold-at-point")
      ("a" fold-this-unfold-all "unfold-all")))
#+END_SRC
*** options
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-options ()
    (defhydra hb/options (hb-mode-map "M-o" :color blue)
      "options"
      ("v" visual-line-mode               "visual-line")
      ("a" auto-fill-mode                 "auto-fill-mode")
      ("f" set-fill-column                "fill-column")
      ("o" follow-mode-80-char-compliant  "follow-mode")
      ("w" writegood-mode                 "writegood-mode")
      ("f" font-lock-fontify-buffer       "fontify-buffer")
      ("s" meslo-face                     "meslo-face")
      ("n" menlo-face                     "menlo-face")
      ("b" bitstream-face                 "bistream-face")
      ("c" courier-face                   "courier-face")))
#+END_SRC
* packages
** ace-window
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-window
    :ensure t
    :config
    (bind-key "C-x p" 'ace-window hb-mode-map)
    (setq aw-leading-char-style 'path
          aw-keys (number-sequence 97 (+ 97 26)))
    (custom-set-faces '(aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0))))))
#+END_SRC
** auto-complete
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auto-complete
    :ensure t
    :config
    (setq ac-use-menu-map t)
    (ac-config-default)
    (setq-default ac-auto-show-menu 0.1)
    (setq-default ac-sources (append '(ac-source-imenu) ac-sources))
    (bind-key "C-n" nil ac-menu-map)
    (bind-key "C-p" nil ac-menu-map)
    (global-auto-complete-mode)
    :diminish "")
#+END_SRC
** bind-key
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bind-key
    :ensure t)
#+END_SRC
** bliss-theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bliss-theme
    :ensure t
    :config
    (load-theme 'bliss t)
    (set-face-attribute 'highlight nil :foreground 'nil :underline 'nil :background "#222222"))
#+END_SRC
** bury-successful-compilation
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bury-successful-compilation
    :ensure t
    :config (bury-successful-compilation))
#+END_SRC
** diminish
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package diminish
    :commands diminish
    :config
    (diminish 'auto-fill-function)
    (diminish 'visual-line-mode))
#+END_SRC
** ediff
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ediff
    :ensure t
    :config (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :ensure t
    :config
    (bind-key "C-=" 'er/expand-region hb-mode-map)
    (bind-key "C-+" 'er/contract-region hb-mode-map))
#+END_SRC
** fic-mode
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-fic-mode ()
    (turn-on-fic-mode)
    (diminish 'fic-mode ""))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fic-mode
    :ensure t
    :config (add-hook 'prog-mode-hook 'hb/configure-fic-mode))
#+END_SRC
** fold-this
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fold-this
    :ensure t)
#+END_SRC
** helm
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-helm ()
    (hb/configure-helm-bindings)
    (hb/configure-helm-preferences))
#+END_SRC
*** preferences
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-helm-preferences ()
    (setq helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match t
          helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match t))
#+END_SRC
*** bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-helm-bindings ()
    (bind-key "C-x b" 'helm-mini hb-mode-map)
    (bind-key "M-y" 'helm-show-kill-ring hb-mode-map)
    (bind-key "C-x C-f" 'helm-find-files hb-mode-map)
    (bind-key "M-i" 'helm-semantic-or-imenu hb-mode-map))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm
    :ensure t
    :config
    (hb/configure-helm))
#+END_SRC
** ibuffer-vc
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer-vc
    :ensure t
    :config
    (add-hook 'ibuffer-mode-hook 'ibuffer-vc-set-filter-groups-by-vc-root))
#+END_SRC
** icomplete+
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package icomplete+
    :ensure t
    :config (icomplete-mode))
#+END_SRC
** ido
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-ido ()
    (hb/configure-ido-preferences)
    (advice-add 'ido-init-completion-maps :after
                #'hb/configure-ido-bindings))
#+END_SRC
*** preferences
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-ido-preferences ()
    (setq ido-enable-flex-matching t
            ido-everywhere t
            ido-max-directory-size 100000
            ido-create-new-buffer 'always
            ido-default-file-method 'selected-window
            ido-default-buffer-method 'selected-window))
#+END_SRC
*** bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-ido-bindings ()
    (bind-key "C-a" nil ido-common-completion-map))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido
    :ensure t
    :config
    (hb/configure-ido))
#+END_SRC
** ido-complete-space-or-hyphen
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido-complete-space-or-hyphen
    :ensure t
    :config
    (ido-complete-space-or-hyphen-enable))
#+END_SRC
** ido-hacks
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido-hacks
    :ensure t
    :config
    (ido-mode 1)
    (ido-hacks-mode 1))
#+END_SRC
** ido-vertical
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido-vertical-mode
    :ensure t
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-show-count t
          ido-use-faces t
          ido-vertical-define-keys 'C-n-C-p-up-down-left-right))
#+END_SRC
** multiple-cursors
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc ()
    (hb/configure-mc-isearch)
    (hb/configure-mc-bindings)
    (hb/configure-mc-fixes))
#+END_SRC
*** mc-isearch
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-isearch ()
        (defvar jc/mc-search--last-term nil)
        (defun jc/mc-search (search-command)
          ;; Read new search term when not repeated command or applying to fake cursors
          (when (and (not mc--executing-command-for-fake-cursor)
                     (not (eq last-command 'jc/mc-search-forward))
                     (not (eq last-command 'jc/mc-search-backward)))
            (setq jc/mc-search--last-term (read-from-minibuffer "Search: ")))
          (funcall search-command jc/mc-search--last-term))
        (defun jc/mc-search-forward ()
          "Simplified version of forward search that supports multiple cursors"
          (interactive)
          (jc/mc-search 'search-forward))
        (defun jc/mc-search-backward ()
          "Simplified version of backward search that supports multiple cursors"
          (interactive)
          (jc/mc-search 'search-backward)))
  (after 'multiple-cursors
    (bind-key "C-s" 'jc/mc-search-forward mc/keymap)
    (bind-key "C-r" 'jc/mc-search-backward mc/keymap))
#+END_SRC
*** bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-bindings ()
    (bind-key "C-S-c C-S-c" 'mc/edit-lines hb-mode-map)
    (bind-key "C-S-SPC" 'set-rectangular-region-anchor hb-mode-map)
    (bind-key "C->" 'mc/mark-next-like-this hb-mode-map)
    (bind-key "C-<" 'mc/mark-previous-like-this hb-mode-map)
    (bind-key "C-c C-<" 'mc/mark-all-like-this hb-mode-map)
    (bind-key "C-c C->" 'mc/mark-all-like-this-dwim hb-mode-map)
    (bind-key "C-c ~" 'mc/insert-numbers hb-mode-map)
    (bind-key "M-~" 'mc/sort-regions hb-mode-map)
    (bind-key "C-~" 'mc/reverse-regions hb-mode-map)
    (bind-key "C-S-c C-e" 'mc/edit-ends-of-lines hb-mode-map)
    (bind-key "C-S-c C-a" 'mc/edit-beginnings-of-lines hb-mode-map))
#+END_SRC
*** fixes
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-fixes ()
    (bind-key "M-SPC" 'just-one-space mc/keymap))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :ensure t
    :config (hb/configure-mc))
#+END_SRC
** org
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-org ()
    (setq org-src-window-setup 'other-window
          org-startup-indented t
          org-hide-emphasis-markers t
          org-startup-folded 'content)
    (after 'org-indent
      (diminish 'org-indent-mode ""))
    (bind-key "C-x C-s" 'org-babel-tangle org-mode-map)
    (add-to-list 'org-structure-template-alist
                 '("st"
                   "#+BEGIN_SRC emacs-lisp :tangle yes\n?\n#+END_SRC"
                   "<src lang=\"?\">\n\n</src>"))
    (add-hook 'org-mode-hook 'hb/configure-org-mode-hook))
#+END_SRC
*** hooks
Note that this has a dependency on writegood-mode.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-org-mode-hook ()
    (auto-fill-mode 1)
    (writegood-mode 1)
    (setq-local ac-auto-show-menu 2.0)
    (setq-local ac-delay 2.0))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :ensure t
    :pin org
    :config
    (hb/configure-org))
#+END_SRC
** org-ac
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-ac
    :ensure t
    :config (org-ac/config-default))
#+END_SRC
** paredit
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package paredit
    :ensure t
    :config (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
    :diminish " P")
#+END_SRC
** paredit-everywhere
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package paredit-everywhere
    :ensure t
    :config (add-hook 'prog-mode-hook 'paredit-everywhere-mode)
    :diminish "")
#+END_SRC
** undo-tree
*** configuration
Thanks [[http://whattheemacsd.com/my-misc.el-02.html][Magnar]]!
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-undo-tree ()
    (defadvice undo-tree-undo (around keep-region activate)
      (if (use-region-p)
          (let ((m (set-marker (make-marker) (mark)))
                (p (set-marker (make-marker) (point))))
            ad-do-it
            (goto-char p)
            (set-mark m)
            (set-marker p nil)
            (set-marker m nil))
        ad-do-it)))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :ensure t
    :diminish ""
    :config
    (hb/configure-undo-tree)
    (global-undo-tree-mode))
#+END_SRC
** uniquify
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'post-forward
        uniquify-separator ":")
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :ensure t
    :config (hb/configure-hydra))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :commands magit-status
    :init
    (bind-key "C-c g" 'magit-status hb-mode-map)
    (setq magit-auto-revert-mode-lighter "")
    (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC
** monochrome-theme
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package monochrome-theme
    :ensure t)
#+END_SRC
** smartparens-mode
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-smartparens ()
    (sp-use-paredit-bindings)
    (hb/configure-smartparens-emacs-lisp))
#+END_SRC
*** emacs-lisp
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-smartparens-emacs-lisp ()
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (add-hook 'emacs-lisp-mode-hook 'smartparens-strict-mode)
    (sp-local-pair 'lisp-interaction-mode "'" nil :actions nil)
    (add-hook 'lisp-interaction-mode-hook 'smartparens-strict-mode))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :ensure t
    :diminish ""
    :config
    (smartparens-global-mode)
    (show-smartparens-global-mode)
    (hb/configure-smartparens))
#+END_SRC
** transpose-frame
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package transpose-frame
    :ensure t
    :config (bind-key "M-|" 'transpose-frame hb-mode-map))
#+END_SRC
** winner
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winner
    :ensure t
    :config (winner-mode 1))
#+END_SRC
** windmove
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package windmove
    :ensure t
    :config (windmove-default-keybindings))
#+END_SRC
** writegood-mode
#+BEGIN_SRC emacs-lisp
    (use-package writegood-mode
      :ensure t
      :diminish "")
#+END_SRC
* major-modes
** c++
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-c-common ()
      (setq c-basic-offset 4
            comment-start "/* "
            comment-end " */"))
  (add-hook 'c-mode-common-hook 'hb/configure-c-common)
#+END_SRC
** java
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-java ()
      (setq c-basic-offset 4
            comment-start "/* "
            comment-end " */"))
  (add-hook 'java-mode-hook 'hb/configure-java)
#+END_SRC
* macros
** hb/quotemeta
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/quotemeta (str-val)
    "Return STR-VAL with all non-word characters and / escaped with backslash.

  This is more vigorous than `shell-quote-argument'."
    (save-match-data
      (replace-regexp-in-string "\\([^A-Za-z_0-9 /]\\)" "\\\\\\1" str-val)))
#+END_SRC
** follow-mode-80-char-compliant
Thanks to @EricCrosson.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun follow-mode-80-char-compliant()
    "Open the current buffer in `follow-mode' in as many 80-char
  windows as you can fit on this screen."
    (interactive)
    (delete-other-windows)
    (follow-mode 1)
    (let ((width (window-total-width nil 'floor)))
      (while (> width 80)
        (split-window-horizontally)
        (balance-windows)
        (setq width (window-total-width nil 'floor))))
    (delete-window)
    (balance-windows)
    (recenter-top-bottom))
#+END_SRC
** delete-trailing-whitespace-untabify
I want this to be everywhere except in Makefiles.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq makefile-modes '(makefile-mode
                         makefile-bsdmake-mode
                         makefile-gmake-mode
                         makefile-imake-mode
                         makefile-makepp-mode
                         makefile-automake-mode))

  (defun hb/delete-trailing-whitespace-untabify ()
    (interactive)
    (if (not (member major-mode makefile-modes))
        (progn
          (delete-trailing-whitespace (point-min) (point-max))
          (untabify (point-min) (point-max)))))

  (add-hook 'before-save-hook 'hb/delete-trailing-whitespace-untabify)
#+END_SRC
** scroll-halfpage
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun window-half-height ()
    (max 1 (/ (1- (window-height (selected-window))) 2)))

  (defun hb/scroll-up-halfpage ()
    (interactive)
    (scroll-up (window-half-height)))

  (defun hb/scroll-down-halfpage ()
    (interactive)
    (scroll-down (window-half-height)))
#+END_SRC
** back-to-indentation-or-beginning
This frees up M-m by making C-a do double-duty as beginning-of-line
and back-to-indentation
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun back-to-indentation-or-beginning ()
    (interactive)
    (if (bolp) (back-to-indentation) (beginning-of-line)))
  (bind-key "C-a" 'back-to-indentation-or-beginning hb-mode-map)
#+END_SRC
** visit-term-buffer
Quickly visit an open term buffer
Credits: @bbatsov, http://emacsredux.com/blog/2013/03/29/terminal-at-your-fingertips/
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun visit-term-buffer ()
    "Create or visit a terminal buffer."
    (interactive)
    (if (not (get-buffer "*ansi-term*"))
        (progn
          (split-window-sensibly (selected-window))
          (other-window 1)
          (ansi-term (getenv "SHELL")))
      (switch-to-buffer-other-window "*ansi-term*")))
  (bind-key "C-c t" 'visit-term-buffer hb-mode-map)
#+END_SRC
** ido-goto-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ido-goto-symbol (&optional symbol-list)
    "Refresh imenu and jump to a place in the buffer using Ido."
    (interactive)
    (unless (featurep 'imenu)
      (require 'imenu nil t))
    (cond
     ((not symbol-list)
      (let ((ido-mode ido-mode)
            (ido-enable-flex-matching
             (if (boundp 'ido-enable-flex-matching)
                 ido-enable-flex-matching t))
            name-and-pos symbol-names position)
        (unless ido-mode
          (ido-mode 1)
          (setq ido-enable-flex-matching t))
        (while (progn
                 (imenu--cleanup)
                 (setq imenu--index-alist nil)
                 (ido-goto-symbol (imenu--make-index-alist))
                 (setq selected-symbol
                       (ido-completing-read "Symbol? " symbol-names))
                 (string= (car imenu--rescan-item) selected-symbol)))
        (unless (and (boundp 'mark-active) mark-active)
          (push-mark nil t nil))
        (setq position (cdr (assoc selected-symbol name-and-pos)))
        (cond
         ((overlayp position)
          (goto-char (overlay-start position)))
         (t
          (goto-char position)))))
     ((listp symbol-list)
      (dolist (symbol symbol-list)
        (let (name position)
          (cond
           ((and (listp symbol) (imenu--subalist-p symbol))
            (ido-goto-symbol symbol))
           ((listp symbol)
            (setq name (car symbol))
            (setq position (cdr symbol)))
           ((stringp symbol)
            (setq name symbol)
            (setq position
                  (get-text-property 1 'org-imenu-marker symbol))))
          (unless (or (null position) (null name)
                      (string= (car imenu--rescan-item) name))
            (add-to-list 'symbol-names name)
            (add-to-list 'name-and-pos (cons name position))))))))
  (bind-key "C-c i" 'ido-goto-symbol hb-mode-map)
  (bind-key "C-c I" 'imenu hb-mode-map)
#+END_SRC
** comment-dwim-line
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun comment-dwim-line (&optional arg)
    "Replacement for the comment-dwim command.
  If no region is selected and current line is not blank and we are not at the end of the line,
  then comment current line.
  Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
    (interactive "*P")
    (comment-normalize-vars)
    (if (or (and (not (region-active-p)) (not (looking-at "[ \t]*$"))) (and (not (equal comment-end "")) (looking-at (hb/quotemeta comment-end))))
        (if (looking-at (hb/quotemeta comment-end))
            (progn
              (comment-or-uncomment-region (if (comment-beginning) (comment-beginning) (line-beginning-position)) (line-end-position))
              (delete-trailing-whitespace (line-beginning-position) (line-end-position)))
          (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
      (comment-dwim arg)))

  (bind-key "C-;" 'comment-dwim-line hb-mode-map)
#+END_SRC
** capitalize-dwim
Not sure why this doesn't exist yet.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun capitalize-line-dwim ()
    (interactive)
    (if (region-active-p)
        (save-excursion
          (let ((beg (region-beginning))
                (end (region-end)))
            (capitalize-region beg end)))
      (save-excursion
        (let ((beg (line-beginning-position))
              (end (line-end-position)))
          (capitalize-region beg end)))))

  (bind-key "C-x c" 'capitalize-line-dwim hb-mode-map)
#+END_SRC
* conclusion
Open this file
#+BEGIN_SRC emacs-lisp :tangle yes
  (find-file "~/.emacs.d/init.org")
#+END_SRC

* [0/18] todos
:PROPERTIES:
:visibility: overview
:END:
** TODO :org: find out how to use orgmode tags properly
Reference [[http://orgmode.org/manual/Tags.html][the org manual]].
** TODO :annoy:org: don't allow 'org-edit-special' to clobber my window config
** TODO :annoy: make something similar to esc's should-have functions
** TODO :annoy: delete-that-newly-opened-window
- add to movement hydra ("d"?)
** TODO :annoy: reopen-in-other-window
- add to movement hydra ("o"?)
** TODO :annoy:org: add org fly-dictate minor mode
Should automatically correct dictation issues. Prospective features:
- make heading titles capitalized
  - except when there are more than two consecutive upper case characters
    - if so, ignore that word
    - else continue capitalizing
- automatically create definitions based on dictating a specific word
  or phrase:
  - maybe a way to dictate a M-x command?
    - "dictate-meta-x"!
- if there is a capital letter in the middle of a word, that probably
  means that the word needs to be split
  - e.g. thisThat -> this that
  - determine when the concatenation needs to be split into two
    sentences or two words
** TODO :magit:hydra:git: make git hydra
should have some common vc, magit, git-messenger, and git-timemachine
commands
** TODO :annoy: set up c++ indentation rules properly
- public/private spacing
- set up style
- constructor arguments should be auto-filled and c-basic-offset
  tabbed
  - the constructor argument name and type should not be broken across
    lines
** TODO :dired: investigate up dired-single
- [[http://www.emacswiki.org/emacs/dired-single.el]]
** TODO :convenience: investigate company-mode
** TODO :convenience: integrate semantic with c/c++
** TODO :convenience: investigate test-map
** TODO :convenience: investivate paredit vs smartparens
** TODO :annoy: get smartparens to close quotes properly
** TODO :annoy: remove single quotes from smartparens pairs
** TODO :annoy:convenience: investigate and change bindings for ido
** TODO investigate req-package
This will fix writegood-mode and org-mode dependencies
** TODO investigate shell-pop
** TODO investigate helm
[[http://tuhdo.github.io/helm-intro.html][Helm intro]]
** TODO investigate projectile
** TODO investigate flx-ido
** TODO add before-save-hook to create immediate dirs
Something like...
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (and (not (file-exists-p dir))
                           (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                  (make-directory dir t))))))
#+END_SRC
** TODO layer maps above a mode's map so I don't override its bindings
