* init.org
** introduction
** use-package
First we must initialize use-package.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

  (package-initialize)

  ;; Bootstrap `use-package'
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)
#+END_SRC
** after
#+BEGIN_SRC emacs-lisp :tangle yes
  (defmacro after (mode &rest body)
    "`eval-after-load' MODE evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,mode
       '(progn ,@body)))
#+END_SRC
** whoami
Who am I?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name "Hershal Bhave"
      user-mail-address "hershal.bhave@gmail.com")
#+END_SRC
** misc-defaults
Let's set some (sensible) defaults that don't go anywhere else.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore
        search-whitespace-regexp "[ \t\r\n\-]+"
        inhibit-startup-screen t)
#+END_SRC
** hb-mode
Set up hb-mode and hb-mode-map.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar hb-mode-map (make-keymap) "hb-mode keymap.")
  (define-minor-mode hb-mode
    "Toggle hb-mode.
       A minor mode so that my key settings override any major modes'."
    t " hb" 'hb-mode-map)
  (hb-mode 1)               ;enable my minor mode, except in minibuffer
  (diminish 'hb-mode)
  (add-hook 'minibuffer-setup-hook (lambda() (hb-mode 0)))
#+END_SRC
** test-map

* os-specific
** linux
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (equal window-system 'x)
      (progn
        (cond
         ((find-font (font-spec :name "Meslo LG S"))
          (set-default-font "Meslo LG S 8"))
         ((find-font (font-spec :name "Bitstream Vera Sans Mono"))
          (set-default-font "Bitstream Vera Sans Mono 8"))
         ((find-font (font-spec :name "-adobe-courier-medium-r-normal-*-*-*-100-100-*-60-iso10646-1"))
          (set-default-font "-adobe-courier-medium-r-normal-*-*-*-100-100-*-60-iso10646-1")))
        (bind-key "s-u" 'revert-buffer hb-mode-map)))
#+END_SRC
** osx
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (equal window-system 'ns)
      (set-default-font "Menlo 10"))
#+END_SRC
* general
** window system
These usually exist when using a window system. Let's make that not
so.
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (window-system)
      (progn (scroll-bar-mode 0)
             (tool-bar-mode 0)
             (blink-cursor-mode 0)
             (set-fringe-mode 0)))
#+END_SRC

This exists regardless of whether we use a windowing system, so
disable those too.
#+BEGIN_SRC emacs-lisp :tangle yes
(menu-bar-mode 0)
#+END_SRC

** portables
Activate display-battery-mode.
#+BEGIN_SRC emacs-lisp :tangle yes
  (display-battery-mode 1)
#+END_SRC

** nuisances
Remove the yes-or-no prompts and replace them with y-or-n.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Also remove all dialog boxes
#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice yes-or-no-p (around prevent-dialog activate)
    "Prevent yes-or-no-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
  (defadvice y-or-n-p (around prevent-dialog-yorn activate)
    "Prevent y-or-n-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
#+END_SRC

** bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (bind-key "C-c C-m"    'recompile hb-mode-map)
  (bind-key "C-c m"      'compile hb-mode-map)
  (bind-key "C-x C-b"    'ido-switch-buffer hb-mode-map)
  (bind-key "C-x O"      'ff-find-other-file hb-mode-map)
  (bind-key "C-'"        'execute-extended-command hb-mode-map)
  (bind-key "C-x C-h"    'hb/delete-trailing-whitespace-untabify hb-mode-map)
  (bind-key "M-|"        'transpose-frame hb-mode-map)
  (bind-key "C-M-S-q"    'fill-region-as-paragraph hb-mode-map)
  (bind-key "M-'"        'query-replace hb-mode-map)
  (bind-key "M-\""       'query-replace-regexp hb-mode-map)
  (bind-key "M-Q"        'fill-region hb-mode-map)
  (bind-key "C-o"        'split-line hb-mode-map)
  (bind-key "C-x K"      'kill-buffer-and-window hb-mode-map)
  (bind-key "C-x C-S-f"  'find-file-other-window hb-mode-map)
  (bind-key "C-'"        'execute-extended-command hb-mode-map)
  (bind-key "M-SPC"      'cycle-spacing hb-mode-map)
  (bind-key "M-;"        'replace-regexp hb-mode-map)
#+END_SRC
** general-general
Very general stuff here. I don't know where to categorize this, so
general-general.
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-auto-revert-mode t)
  (set-buffer-file-coding-system 'unix)
  (setq-default indent-tabs-mode nil)

  ;;; show paren mode
  (show-paren-mode t)
  (setq show-paren-style 'mixed)

  (setq vc-follow-symlinks t)
  (setq ediff-auto-refine 'on)
  (setq ring-bell-function 'ignore)
  (setq backup-directory-alist `((".*" . , "~/.emacs-backups/")))
  (setq tramp-auto-save-directory "~/.emacs-backups/")
  (setq kill-whole-line t)
  (setq size-indication-mode t)

  (setq display-time-24hr-format t)
  (setq display-time-mode t)

  (toggle-truncate-lines 1)
#+END_SRC

** hydras
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra ()
    (hb/configure-hydra-movement)
    (hb/configure-hydra-fold-this)
    (hb/configure-hydra-options))
#+END_SRC
*** movement
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-movement ()
    (setq scroll-amount 10)
    (defhydra hb/hydra-movement (hb-mode-map "M-m" :color red)
      "movement"
      ("j"     (scroll-up scroll-amount)     "down")
      ("k"     (scroll-down scroll-amount)   "up")
      ("f"     hb/scroll-up-halfpage         "down half")
      ("b"     hb/scroll-down-halfpage       "up half")
      ("SPC"   scroll-up                     "down full")
      ("S-SPC" scroll-down                   "up full")
      ("s"     isearch-forward               "isearch")
      ("v"     visual-line-mode              "visual-line")
      ("a"     auto-fill-mode                "auto-fill-mode")
      ("i"     set-fill-column               "fill-column")
      ("o"     follow-mode                   "follow-mode")
      ("w"     ace-window                    "ace-window")
      ("8"     follow-mode-80-char-compliant "follow-mode-80-char")))
#+END_SRC
*** fold-this
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-fold-this ()
    (defhydra hb/fold-this (hb-mode-map "C-x f" :color blue)
      "fold-this"
      ("f" fold-this "fold-this")
      ("u" fold-this-unfold-at-point "unfold-at-point")
      ("a" fold-this-unfold-all "unfold-all")))
#+END_SRC
*** options
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-hydra-options ()
    (defhydra hb/options (hb-mode-map "M-o" :color blue)
      "options"
      ("v" visual-line-mode          "visual-line")
      ("a" auto-fill-mode            "auto-fill-mode")
      ("f" set-fill-column           "fill-column")
      ("o" follow-mode               "follow-mode")
      ("w" writegood-mode            "writegood-mode")
      ("f" font-lock-fontify-buffer  "fontify-buffer")
      ("m" meslo-face                "meslo-face")
      ("b" bitstream-face            "bistream-face")
      ("c" courier-face              "courier-face")))
#+END_SRC
* packages
** ace-window
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-window
    :config
    (bind-key "C-x p" 'ace-window hb-mode-map)
    (setq aw-leading-char-style 'path
          aw-keys (number-sequence 97 (+ 97 26)))
    (custom-set-faces '(aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0))))))
#+END_SRC
** auto-complete
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auto-complete
    :config
    (setq ac-use-menu-map t)
    (ac-config-default)
    (setq-default ac-auto-show-menu 0.1)
    (setq-default ac-sources (append '(ac-source-imenu) ac-sources))
    (bind-key "C-n" nil ac-menu-map)
    (bind-key "C-p" nil ac-menu-map)
    (global-auto-complete-mode)
    :diminish "")
#+END_SRC
** bind-key
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bind-key)
#+END_SRC
** bliss-theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bliss-theme
    :config
    '(load-theme 'bliss t)
    (set-face-attribute 'highlight nil :foreground 'nil :underline 'nil :background "#222222"))
#+END_SRC
** bury-successful-compilation
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bury-successful-compilation
    :config (bury-successful-compilation))
#+END_SRC
** TODO desktop-mode
** diminish
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package diminish
    :commands diminish)
#+END_SRC
** ediff
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ediff
    :config (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :config
    (bind-key "C-=" 'er/expand-region hb-mode-map)
    (bind-key "C-+" 'er/contract-region) hb-mode-map)
#+END_SRC
** fic-mode
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package fic-mode)
#+END_SRC
** fold-this
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fold-this)
#+END_SRC
** icomplete+
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package icomplete+
    :config (icomplete-mode))
#+END_SRC
** ido
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido
    :config
    (setq ido-enable-flex-matching t
          ido-everywhere t
          ido-max-directory-size 100000
          ido-create-new-buffer 'always
          ido-default-file-method 'selected-window
          ido-default-buffer-method 'selected-window))
#+END_SRC
** ido-complete-space-or-hyphen
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido-complete-space-or-hyphen
    :config
    (ido-complete-space-or-hyphen-enable))
#+END_SRC
** ido-hacks
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido-hacks
    :config
    (ido-mode 1)
    (ido-hacks-mode 1))
#+END_SRC
** ido-vertical
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ido-vertical-mode
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-show-count t
          ido-use-faces t
          ido-vertical-define-keys 'C-n-C-p-up-down-left-right))
#+END_SRC
** multiple-cursors
*** configuration
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc ()
    (hb/configure-mc-isearch)
    (hb/configure-mc-bindings)
    (hb/configure-mc-fixes))
#+END_SRC
*** mc-isearch
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-isearch ()
        (defvar jc/mc-search--last-term nil)
        (defun jc/mc-search (search-command)
          ;; Read new search term when not repeated command or applying to fake cursors
          (when (and (not mc--executing-command-for-fake-cursor)
                     (not (eq last-command 'jc/mc-search-forward))
                     (not (eq last-command 'jc/mc-search-backward)))
            (setq jc/mc-search--last-term (read-from-minibuffer "Search: ")))
          (funcall search-command jc/mc-search--last-term))
        (defun jc/mc-search-forward ()
          "Simplified version of forward search that supports multiple cursors"
          (interactive)
          (jc/mc-search 'search-forward))
        (defun jc/mc-search-backward ()
          "Simplified version of backward search that supports multiple cursors"
          (interactive)
          (jc/mc-search 'search-backward)))
  (after 'multiple-cursors
    (bind-key "C-s" 'jc/mc-search-forward mc/keymap)
    (bind-key "C-r" 'jc/mc-search-backward mc/keymap))
#+END_SRC
*** bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-bindings ()
    (bind-key "C-S-c C-S-c" 'mc/edit-lines hb-mode-map)
    (bind-key "C-S-SPC" 'set-rectangular-region-anchor hb-mode-map)
    (bind-key "C->" 'mc/mark-next-like-this hb-mode-map)
    (bind-key "C-<" 'mc/mark-previous-like-this hb-mode-map)
    (bind-key "C-c C-<" 'mc/mark-all-like-this hb-mode-map)
    (bind-key "C-c C->" 'mc/mark-all-like-this-dwim hb-mode-map)
    (bind-key "C-c ~" 'mc/insert-numbers hb-mode-map)
    (bind-key "M-~" 'mc/sort-regions hb-mode-map)
    (bind-key "C-~" 'mc/reverse-regions hb-mode-map)
    (bind-key "C-S-c C-e" 'mc/edit-ends-of-lines hb-mode-map)
    (bind-key "C-S-c C-a" 'mc/edit-beginnings-of-lines hb-mode-map))
#+END_SRC
*** fixes
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-mc-fixes ()
    (bind-key "M-SPC" 'just-one-space mc/keymap))
#+END_SRC
*** package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :config (hb/configure-mc))
#+END_SRC
** org
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :config
    (setq org-src-window-setup 'other-window
          org-startup-indented t
          org-hide-emphasis-markers t
          org-startup-folded 'content)
    (after 'org-indent
      (diminish 'org-indent-mode ""))
    (bind-key "C-x C-s" 'org-babel-tangle org-mode-map))
#+END_SRC
** paredit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paredit
      :config (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
      :diminish " P")
#+END_SRC
** paredit-everywhere
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paredit-everywhere
      :config (add-hook 'prog-mode-hook 'paredit-everywhere-mode)
      :diminish "")
#+END_SRC
** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :config (global-undo-tree-mode)
    :diminish "")
#+END_SRC
** TODO uniquify
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'post-forward
        uniquify-separator ":")
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :config (hb/configure-hydra))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :commands magit-status
    :init
    (bind-key "C-c g" 'magit-status hb-mode-map)
    (setq magit-auto-revert-mode-lighter ""))
#+END_SRC
** monochrome-theme
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package monochrome-theme)
#+END_SRC
** smartparens-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :config (smartparens-global-mode)
    :diminish "")
#+END_SRC
** transpose-frame
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package transpose-frame
    :config (bind-key "M-|" 'transpose-frame hb-mode-map))
#+END_SRC
** winner
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winner
    :config (winner-mode 1))
#+END_SRC
** windmove
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package windmove
    :config (windmove-default-keybindings))
#+END_SRC
** writegood-mode
#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode)
#+END_SRC
* major-modes
** c++
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-c-common ()
      (setq c-basic-offset 4
            comment-start "/* "
            comment-end " */")
      (after 'fic-mode
        (turn-on-fic-mode)))
  (add-hook 'c-mode-common-hook 'hb/configure-c-common)
#+END_SRC
** java
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/configure-java ()
      (setq c-basic-offset 4
            comment-start "/* "
            comment-end " */")
      (after 'fic-mode
        (turn-on-fic-mode)))
  (add-hook 'java-mode-hook 'hb/configure-java)
#+END_SRC
* macros
** hb/quotemeta
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hb/quotemeta (str-val)
    "Return STR-VAL with all non-word characters and / escaped with backslash.

  This is more vigorous than `shell-quote-argument'."
    (save-match-data
      (replace-regexp-in-string "\\([^A-Za-z_0-9 /]\\)" "\\\\\\1" str-val)))
#+END_SRC
** follow-mode-80-char-compliant
Thanks to @EricCrosson.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun follow-mode-80-char-compliant()
    "Open the current buffer in `follow-mode' in as many 80-char
  windows as you can fit on this screen."
    (interactive)
    (delete-other-windows)
    (follow-mode 1)
    (let ((width (window-total-width nil 'floor)))
      (while (> width 80)
        (split-window-horizontally)
        (balance-windows)
        (setq width (window-total-width nil 'floor))))
    (delete-window)
    (balance-windows)
    (recenter-top-bottom))
#+END_SRC
** delete-trailing-whitespace-untabify
I want this to be everywhere except in Makefiles.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq makefile-modes '(makefile-mode
                         makefile-bsdmake-mode
                         makefile-gmake-mode
                         makefile-imake-mode
                         makefile-makepp-mode
                         makefile-automake-mode))

  (defun hb/delete-trailing-whitespace-untabify ()
    (interactive)
    (if (not (member major-mode makefile-modes))
        (progn
          (delete-trailing-whitespace (point-min) (point-max))
          (untabify (point-min) (point-max)))))

  (add-hook 'before-save-hook 'hb/delete-trailing-whitespace-untabify)
#+END_SRC
** scroll-halfpage
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun window-half-height ()
    (max 1 (/ (1- (window-height (selected-window))) 2)))

  (defun hb/scroll-up-halfpage ()
    (interactive)
    (scroll-up (window-half-height)))

  (defun hb/scroll-down-halfpage ()
    (interactive)
    (scroll-down (window-half-height)))
#+END_SRC
** back-to-indentation-or-beginning
This frees up M-m by making C-a do double-duty as beginning-of-line
and back-to-indentation
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun back-to-indentation-or-beginning ()
    (interactive)
    (if (bolp) (back-to-indentation) (beginning-of-line)))
  (bind-key "C-a" 'back-to-indentation-or-beginning hb-mode-map)
#+END_SRC
** visit-term-buffer
Quickly visit an open term buffer
Credits: @bbatsov, http://emacsredux.com/blog/2013/03/29/terminal-at-your-fingertips/
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun visit-term-buffer ()
    "Create or visit a terminal buffer."
    (interactive)
    (if (not (get-buffer "*ansi-term*"))
        (progn
          (split-window-sensibly (selected-window))
          (other-window 1)
          (ansi-term (getenv "SHELL")))
      (switch-to-buffer-other-window "*ansi-term*")))
  (bind-key "C-c t" 'visit-term-buffer hb-mode-map)
#+END_SRC
** ido-goto-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ido-goto-symbol (&optional symbol-list)
    "Refresh imenu and jump to a place in the buffer using Ido."
    (interactive)
    (unless (featurep 'imenu)
      (require 'imenu nil t))
    (cond
     ((not symbol-list)
      (let ((ido-mode ido-mode)
            (ido-enable-flex-matching
             (if (boundp 'ido-enable-flex-matching)
                 ido-enable-flex-matching t))
            name-and-pos symbol-names position)
        (unless ido-mode
          (ido-mode 1)
          (setq ido-enable-flex-matching t))
        (while (progn
                 (imenu--cleanup)
                 (setq imenu--index-alist nil)
                 (ido-goto-symbol (imenu--make-index-alist))
                 (setq selected-symbol
                       (ido-completing-read "Symbol? " symbol-names))
                 (string= (car imenu--rescan-item) selected-symbol)))
        (unless (and (boundp 'mark-active) mark-active)
          (push-mark nil t nil))
        (setq position (cdr (assoc selected-symbol name-and-pos)))
        (cond
         ((overlayp position)
          (goto-char (overlay-start position)))
         (t
          (goto-char position)))))
     ((listp symbol-list)
      (dolist (symbol symbol-list)
        (let (name position)
          (cond
           ((and (listp symbol) (imenu--subalist-p symbol))
            (ido-goto-symbol symbol))
           ((listp symbol)
            (setq name (car symbol))
            (setq position (cdr symbol)))
           ((stringp symbol)
            (setq name symbol)
            (setq position
                  (get-text-property 1 'org-imenu-marker symbol))))
          (unless (or (null position) (null name)
                      (string= (car imenu--rescan-item) name))
            (add-to-list 'symbol-names name)
            (add-to-list 'name-and-pos (cons name position))))))))
  (bind-key "C-c i" 'ido-goto-symbol hb-mode-map)
  (bind-key "C-c I" 'imenu hb-mode-map)
#+END_SRC
** comment-dwim-line
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun comment-dwim-line (&optional arg)
    "Replacement for the comment-dwim command.
          If no region is selected and current line is not blank and we are not at the end of the line,
          then comment current line.
          Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
    (interactive "*P")
    (comment-normalize-vars)
    (if (or (and (not (region-active-p)) (not (looking-at "[ \t]*$"))) (and (not (equal comment-end "")) (looking-at (hb/quotemeta comment-end))))
        (if (looking-at (hb/quotemeta comment-end))
            (progn
              (comment-or-uncomment-region (comment-beginning) (line-end-position))
              (delete-trailing-whitespace (line-beginning-position) (line-end-position)))
          (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
      (comment-dwim arg)))

  (bind-key "C-;" 'comment-dwim-line hb-mode-map)
#+END_SRC
** faces
*** meslo-face
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun meslo-face ()
    (interactive)
    (set-default-font "Meslo LG S 8"))
#+END_SRC
*** bitstream-face
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun bitstream-face ()
    (interactive)
    (set-default-font "Bitstream Vera Sans Mono 8"))
#+END_SRC
*** courier-face
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun courier-face ()
    (interactive)
    (set-default-font "-adobe-courier-medium-r-normal-*-*-*-100-100-*-60-iso10646-1"))
#+END_SRC
* conclusion
#+BEGIN_SRC emacs-lisp

#+END_SRC

* TODO [0/12] todos
** TODO :emacs: macro to create 'BEGIN_SRC emacs-lisp :tangle yes' blocks
** TODO :autocomplete:org: get ac-complete-org working
** TODO :org: find out how to use orgmode tags properly
Reference [[http://orgmode.org/manual/Tags.html][the org manual]].
** TODO :annoy:org: don't allow 'org-edit-special' to clobber my window config
** TODO :annoy: make something similar to esc's should-have functions
** TODO :annoy: delete-that-newly-opened-window
- add to movement hydra ("d"?)
** TODO :annoy: reopen-in-other-window
- add to movement hydra ("o"?)
** TODO custom mode
- turn on and off various minor modes
** TODO :annoy:org: add org fly-dictate minor mode
Should automatically correct dictation issues. Prospective features:
- make heading titles capitalized
  - except when there are more than two consecutive upper case characters
    - if so, ignore that word
    - else continue capitalizing
- automatically create definitions based on dictating a specific word
  or phrase:
  - maybe a way to dictate a M-x command?
    - "dictate-meta-x"!
- if there is a capital letter in the middle of a word, that probably
  means that the word needs to be split
  - e.g. thisThat -> this that
  - determine when the concatenation needs to be split into two
    sentences or two words
** TODO :magit:hydra:git: make git hydra
should have some common vc, magit, git-messenger, and git-timemachine
commands
** TODO :annoy: set up c++ indentation rules properly
- public/private spacing
- verify c-basic-offset
- set up style
- constructor arguments should be auto-filled and c-basic-offset
  tabbed
  - the constructor argument name and type should not be broken across
    lines
** TODO :dired: investigate up dired-single
- [[http://www.emacswiki.org/emacs/dired-single.el]]
